# Building microservices with Java EE 8 and MicroProfile

These are the demo instructions for the JCON 2018 talk.

## Prerequisites

* Basic programming skills and Java knowledge
* Working JDK installation, at least Java 8 (e.g. https://adoptopenjdk.net)
* IDE with Java and Java EE 8 support (e.g. IntelliJ IDEA or Visual Studio Code)
* Git Client (e.g. SourceTree or any console Git client)
* Docker for Windows or Mac installed

To get you started quickly, issue the following commands on the CLI:

```
$ git clone https://github.com/lreimer/building-javaee-microservices.git
$ cd building-javaee-microservices
$ git checkout jcon2018
$ ./gradlew build

$ docker pull qaware/zulu-centos-payara-micro:8u181-5.183
```

## Getting started with Java EE 8 microservices

### Build and dependency setup for Gradle

Create a `build.gradle` file, apply the WAR plugin and add the Java EE 8
dependency (see https://mvnrepository.com/artifact/javax/javaee-api/8.0).
This is what the final result should look like:
```groovy
plugins {
    id 'war'
}

repositories { jcenter() }

dependencies {
    providedCompile 'javax:javaee-api:8.0'
    // not part of Java EE API, optional
    providedCompile 'javax.cache:cache-api:1.0.0'
}
```

### Implement simple JAX-RS application and REST resource

First, create the JAX-RS application class and add the `@ApplicationPath` annotation.
```java
@ApplicationPath("api")
public class JAXRSConfiguration extends Application {
}
```

Next, create a resource class for your Hello REST endpoint.
```java
@Path("hello")
public class HelloWorldResource {
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public JsonObject helloWorld() {
        String hostname = ofNullable(getenv("HOSTNAME")).orElse("localhost");
        return Json.createObjectBuilder()
                .add("message", "Cloud Native Application Development with Java EE.")
                .add("hostname", hostname)
                .build();
    }
}
```

### Add the MicroProfile 2.0 dependencies

```groovy
    providedCompile 'org.eclipse.microprofile.config:microprofile-config-api:1.3'
    providedCompile 'org.eclipse.microprofile.metrics:microprofile-metrics-api:1.1.1'
    providedCompile 'org.eclipse.microprofile.fault-tolerance:microprofile-fault-tolerance-api:1.1.2'
    providedCompile 'org.eclipse.microprofile.health:microprofile-health-api:1.0'
    providedCompile 'org.eclipse.microprofile.rest.client:microprofile-rest-client-api:1.1'
    providedCompile 'org.eclipse.microprofile.opentracing:microprofile-opentracing-api:1.1'
    providedCompile 'org.eclipse.microprofile.openapi:microprofile-openapi-api:1.0.1'
```

### Add MicroProfile Config implementation

Add the following configuration class and use the default hostname in the `HelloWorldResource`.

```java
@ApplicationScoped
public class HelloConfiguration {

    @Inject
    @ConfigProperty(name = "hostname", defaultValue = "localhost")
    private String hostname;

    @Inject
    @ConfigProperty(name = "message", defaultValue = "Building Microservices with Java EE 8 and MicroProfile.")
    private Provider<String> message;

    public String getHostname() {
        return hostname;
    }

    public String getMessage() {
        return message.get();
    }
}
```

### Add MicroProfile Health implementation

Add the following `HealthCheck` implementation class to the codebase. Currently, we do not check any
actual backend, this is up to you to implement.

```java
@ApplicationScoped
@Health
public class AlwaysHealthyCheck implements HealthCheck {
    @Override
    public HealthCheckResponse call() {
        return HealthCheckResponse.builder()
                .name("Java EE 8")
                .withData("message", "Always healthy!")
                .up()
                .build();
    }
}
```

### Add MicroProfile Metrics integation

Now we are adding some basic metrics to the `HelloWorldResource`. Inject a basic counter and annotate the resource
method using `@Timed`.

```java
    @Inject
    @Metric(name = "helloWorldCounter", absolute = true)
    private Counter counter;

    @Timed(name = "helloWorld", absolute = true, unit = MetricUnits.MILLISECONDS)
    public JsonObject helloWorld() { ... }
```

The metrics endpoint is now available under `http://localhost:8080/metrics` for all metrics, or under
`http://localhost:8080/health/application` for application metrics only.

### Add MicroProfile OpenAPI definitions

First, add an Open API definition annotation to the `package-info.java`.

```java
@OpenAPIDefinition(
        info = @Info(title = "Java EE 8 Microservice API",
                contact = @Contact(name = "M.-Leander Reimer", email = "mario-leander.reimer@qaware.de"),
                license = @License(name = "MIT"),
                version = "1.0.0"),
        tags = {
                @Tag(name = "Java EE 8"),
                @Tag(name = "Eclipse MicroProfile")
        },
        servers = {
                @Server(url = "localhost:8080/api/")
        },
        externalDocs = @ExternalDocumentation(url = "www.google.com", description = "Use Google for external documentation")
)
package cloud.nativ.javaee;
```

Each REST operation also needs to be annotated, so add the following annotation to the `helloWorld()` method.
```java
    @APIResponse(responseCode = "200", description = "The hello world response.",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = JsonObject.class)))
    @Operation(summary = "Do hello world.", description = "Retrieve JSON response with message and hostname.")
```

The Open API endpoint is now available under `http://localhost:8080/openapi/`.

### Add MicroProfile RestClient implementation

In order to call the OpenWeatherMap API, we will add and implement the following typed interface.

```java
@RegisterRestClient
@Path("/data/2.5/weather")
public interface OpenWeatherMap {
    @GET
    @Consumes(MediaType.APPLICATION_JSON)
    JsonObject getWeather(@QueryParam("q") String city, @QueryParam("APPID") String appid);
    
    @GET
    @Consumes(MediaType.APPLICATION_JSON)
    CompletionStage<JsonObject> getWeatherAsync(@QueryParam("q") String city, @QueryParam("APPID") String appid);
}
```

Then add a repository implementation and configuration to use the REST client interface. We also make use of
JCache APIs to cache the weather response, and we leverage JSON-P to extract only certain parts from the response.

```java
@ApplicationScoped
public class OpenWeatherMapConfiguration {

    @Inject
    @ConfigProperty(name = "weather.appid", defaultValue = "5b3f51e527ba4ee2ba87940ce9705cb5")
    private Provider<String> weatherAppId;

    @Inject
    @ConfigProperty(name = "weather.uri", defaultValue = "https://api.openweathermap.org")
    private Provider<String> weatherUri;

    public String getWeatherAppId() {
        return weatherAppId.get();
    }

    public String getWeatherUri() {
        return weatherUri.get();
    }
}

@Log
@ApplicationScoped
public class OpenWeatherMapRepository {

    @Inject
    private OpenWeatherMapConfiguration configuration;
    
    @Inject
    private Event<CurrentWeather> weatherEvent;

    private OpenWeatherMap openWeatherMap;

    @PostConstruct
    void initialize() {
        try {
            openWeatherMap = RestClientBuilder.newBuilder()
                    .baseUri(new URI(configuration.getWeatherUri()))
                    .build(OpenWeatherMap.class);
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException(e);
        }
    }

    @Timeout(value = 5L, unit = ChronoUnit.SECONDS)
    @Retry(delay = 500L, maxRetries = 1)
    @Fallback(fallbackMethod = "defaultWeather")
    @CacheResult(cacheName = "weatherCache")
    public String getWeather(String city) {
        JsonObject response = openWeatherMap.getWeather(city, configuration.getWeatherAppId());
        LOGGER.log(Level.INFO, "Received {0}", response);

        JsonPointer pointer = Json.createPointer("/weather/0/main");
        String weather = ((JsonString) pointer.getValue(response)).getString();

        weatherEvent.fireAsync(new CurrentWeather(city, weather));

        return weather;
    }

    public String defaultWeather(String city) {
        return "Unknown";
    }
}
``` 

## Add asynchronous REST API implementation

Next, we add a REST API to access the weather for a given city, using the OpenWeatherMap API from the previous step.
We make use of the asynchronous JAX-RS capabilities using `@Suspended AsyncResponse asyncResponse`.

```java
@ApplicationScoped
@Path("weather")
public class WeatherResource {

    @Inject
    private OpenWeatherMapRepository repository;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @APIResponse(responseCode = "200", description = "The current weather for the city.",
            content = @Content(mediaType = "text/plain", schema = @Schema(implementation = String.class)))
    @Operation(summary = "Get the current weather for a city.",
            description = "Retrieves the current weather via the OpenWeatherMap API.")
    @Path("/{city}")
    public void getWeather(@Suspended final AsyncResponse asyncResponse,
                           @Parameter(name = "city", required = true, example = "Rosenheim,de",
                                   schema = @Schema(type = SchemaType.STRING))
                           @PathParam("city") String city) {

        asyncResponse.setTimeout(5, TimeUnit.SECONDS);
        asyncResponse.setTimeoutHandler(r -> r.resume(Response.status(Response.Status.SERVICE_UNAVAILABLE).build()));
        asyncResponse.resume(Response.ok(repository.getWeather(city)).build());
    }
}
```

## Add Server-sent Events (SSE) for push communication with UI

Every good service or self-contained system (SCS) needs a UI. Java EE and JAX-RS provide SSE support to easily implement
server-side push without the need for web sockets.

Add the UI specific resource implementation to provide the POST based query endpoint as well as the SSE 
broadcast implementation.

```java
@Log
@ApplicationScoped
@Path("weather-station")
public class WeatherStationResource {

    @Inject
    private OpenWeatherMapRepository repository;

    @Context
    private Sse sse;
    private SseBroadcaster sseBroadcaster;

    private AtomicLong registeredEventSinks = new AtomicLong(0);

    @PostConstruct
    public void initialize() {
        sseBroadcaster = sse.newBroadcaster();

        sseBroadcaster.onClose((eventSink) -> {
            long count = registeredEventSinks.decrementAndGet();
            LOGGER.log(Level.INFO, "Closing sink. Currently {0} events sinks listening.", count);
        });

        sseBroadcaster.onError((sseEventSink, throwable) -> {
            long count = registeredEventSinks.decrementAndGet();
            LOGGER.log(Level.WARNING, "Error on event sink. Currently {0} events sinks listening.", new Object[]{count, throwable});
        });
    }

    @GET
    @Produces(MediaType.SERVER_SENT_EVENTS)
    public void fetch(@Context SseEventSink sseEventSink) {
        LOGGER.info("Registering new SSE event sink with broadcaster.");
        sseBroadcaster.register(sseEventSink);

        long count = registeredEventSinks.incrementAndGet();
        LOGGER.log(Level.INFO, "Currently {0} events sinks listening.", count);
    }

    @POST
    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
    @Produces(MediaType.TEXT_PLAIN)
    @Timed(name = "queryWeather", absolute = true, unit = MetricUnits.MILLISECONDS)
    public Response queryWeather(@FormParam("city") @NotBlank String city) {
        LOGGER.log(Level.INFO, "Received weather form POST request for city {0}", city);
        return Response.ok(repository.getWeather(city)).build();
    }

    @Gauge(unit = "none")
    public long registeredEventSinks() {
        return registeredEventSinks.get();
    }

    public void broadcast(@ObservesAsync CurrentWeather currentWeather) {
        OutboundSseEvent broadcastEvent = sse.newEventBuilder()
                .name("event")
                .data(currentWeather.toJson())
                .mediaType(MediaType.APPLICATION_JSON_TYPE)
                .build();

        LOGGER.log(Level.INFO, "Broadcasting current weather event {0}.", broadcastEvent);
        sseBroadcaster.broadcast(broadcastEvent);
    }
}
```

Add the following JSP file to `sr/main/webapp/` to be able to query the current weather as well as receive 
all current weather events.

```jsp
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Building microservices with Java EE 8 and Microprofile APIs</title>

    <link href="css/bootstrap.min.css" rel="stylesheet">
</head>
<body>

<script src="js/jquery.min.js"></script>
<script src="js/bootstrap.min.js"></script>

<div class="container theme-showcase" role="main">

    <div class="jumbotron">
        <h1>Java EE 8 Weather Station</h1>
    </div>

    <div class="row">
        <div class="col-md-6">
            <form action="" method="post" onsubmit="submitForm(); return false;">
                <div class="form-group">
                    <label for="city">City</label>
                    <input type="text" class="form-control" id="city" placeholder="Munich,de">
                </div>
                <button type="submit" class="btn btn-primary">Submit</button>
            </form>
            <script>
                function submitForm() {
                    var urlEncodedData;
                    var urlEncodedDataPairs = [];
                    var http = new XMLHttpRequest();

                    http.open("POST", "/api/weather-station", true);
                    http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

                    var city = document.getElementById('city').value;
                    document.getElementById('city').value = "";

                    urlEncodedDataPairs.push('city' + '=' + encodeURIComponent(city));

                    urlEncodedData = urlEncodedDataPairs.join('&').replace(/%20/g, '+');
                    http.send(urlEncodedData);
                }
            </script>
        </div>
    </div>

    <div class="row">
        <div class="col-md-6"></div>
    </div>

    <div class="row">
        <div id="events" class="col-md-6">

            <script>
                if (typeof(EventSource) !== "undefined") {
                    var source = new EventSource("/api/weather-station");

                    source.addEventListener("event", function (e) {
                        document.getElementById("events").innerHTML += "Current weather (SSE) in " + e.data + "<br>";
                    }, false);
                } else {
                    document.getElementById("events").innerHTML = "Sorry, your browser does not support server-sent events...";
                }
            </script>
        </div>
    </div>
</div>

</body>
</html>
```

Also make sure to active this page as welcome page in your `web.xml` file.

```xml
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <distributable/>

    <display-name>Weather Station</display-name>

    <welcome-file-list>
        <welcome-file>index.jsp</welcome-file>
    </welcome-file-list>

</web-app>
```

## Add JSON Web Token based security

```
$ cd src/main/resources/
$ openssl genrsa -out baseKey.pem 2048
$ openssl pkcs8 -topk8 -inform PEM -in baseKey.pem -out privateKey.pem -nocrypt
$ openssl rsa -in baseKey.pem -pubout -outform PEM -out publicKey.pem
```